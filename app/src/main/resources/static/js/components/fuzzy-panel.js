/**
 * Creates an Alpine.js data object with fuzzy input functionality
 */
export function fuzzyAddon() {
    return {
        convertToFuzzySearch(glossary) {
            const searchText = glossary.details.searchText || glossary.name;
            if (!searchText || !searchText.trim()) {
                this.showToast('No search text to convert for fuzzy search', true);
                return;
            }

            const text = searchText.trim().toLowerCase();
            const len = text.length;
            const minLen = Math.max(1, Math.floor(len * 0.7));
            const maxLen = Math.ceil(len * 1.3);

            // Generate trigrams with cleaning
            const nGrams = this.generateTrigrams(text);

            const fuzzyData = {
                query: text,
                lengthRange: {
                    min: minLen,
                    max: maxLen
                },
                nGrams: nGrams
            };

            glossary.details.fuzzyText = JSON.stringify(fuzzyData);
        },

        toggleFuzzyMode(glossary) {
            this.glossaryConfigTabs.isFuzzyMode = !this.glossaryConfigTabs.isFuzzyMode;
            if (this.glossaryConfigTabs.isFuzzyMode) {
                // Switch to fuzzy mode
                const searchText = glossary.details.searchText || glossary.name || '';
                glossary.details.fuzzyTextInput = searchText;

                // Always try to generate n-grams when entering fuzzy mode
                const text = searchText.trim().toLowerCase();
                if (text.length >= 3) {
                    // Generate auto n-grams with cleaning
                    glossary.details.activeNGrams = this.generateTrigrams(text);
                } else if (text.length > 0) {
                    // For short text, use the text as single n-gram if possible
                    const trimmedText = text.trim();
                    if (trimmedText.length >= 2) {
                        glossary.details.activeNGrams = [trimmedText];
                    } else {
                        glossary.details.activeNGrams = [];
                    }
                } else {
                    // No text available
                    glossary.details.activeNGrams = [];
                }

                // Update preview after setting n-grams
                this.updateFuzzyPreview(glossary);
                this.applyFuzzyFormat(glossary);
            } else {
                // Switch to regular mode
                this.resetFuzzyState(glossary);
                this.fetchRelatedGlossaryItems(glossary);
            }
        },

        updateFuzzyPreview(glossary) {
            const text = glossary.details.fuzzyTextInput?.trim()?.toLowerCase() || '';
            if (!text) {
                glossary.details.previewStats = {
                    text: '',
                    length: 0,
                    minLen: 0,
                    maxLen: 0,
                    totalNGrams: 0,
                    filteredNGrams: 0,
                    quality: { level: 'None' },
                    prediction: 0,
                    removedCount: 0,
                    removalReasons: []
                };
                glossary.details.activeNGrams = [];
                return;
            }

            const len = text.length;
            const minLen = Math.max(1, Math.floor(len * 0.7));
            const maxLen = Math.ceil(len * 1.3);

            // Use current active n-grams as the source for analysis
            let rawNGrams = glossary.details.activeNGrams || [];

            // If text changed and we previously had auto-generated n-grams, regenerate them for the new text
            if (rawNGrams.length > 0) {
                // Store the current raw n-grams to check later
                const originalRawNGrams = [...rawNGrams];

                const expectedNGrams = text.length >= 3 ? this.generateTrigrams(text) : [];
                const wasAutoGeneratedFromCurrent = expectedNGrams.length > 0 && rawNGrams.every(ngram => expectedNGrams.includes(ngram));

                if (!wasAutoGeneratedFromCurrent) {
                    // Regenerate auto n-grams for the new text (like on toggle switch)
                    if (text.length >= 3) {
                        rawNGrams = this.generateTrigrams(text);
                        glossary.details.activeNGrams = rawNGrams;
                    } else if (text.length >= 2) {
                        rawNGrams = [text];
                        glossary.details.activeNGrams = rawNGrams;
                    } else {
                        rawNGrams = [];
                        glossary.details.activeNGrams = rawNGrams;
                    }
                }
            } else {
                // If no n-grams yet, generate auto ones
                if (text.length >= 3) {
                    rawNGrams = this.generateTrigrams(text);
                    glossary.details.activeNGrams = rawNGrams;
                } else if (text.length >= 2) {
                    rawNGrams = [text];
                    glossary.details.activeNGrams = rawNGrams;
                }
            }

            // Apply intelligent filtering and quality analysis (only filter manually added n-grams)
            let filteredNGrams;
            let nGramStats;
            let isAutoGenerated = false;

            if (rawNGrams.length > 0) {
                // For auto-generated n-grams, keep as is; for manually added, apply filtering
                isAutoGenerated = text.length >= 3 && this.isAutoGeneratedNGrams(text, rawNGrams);
                if (isAutoGenerated || rawNGrams.length < 3) {
                    // Don't filter auto-generated n-grams or short auto ones to keep them all displayed
                    filteredNGrams = rawNGrams;
                    nGramStats = {
                        filtered: rawNGrams,
                        removed: 0,
                        reasons: [],
                        details: {}
                    };
                } else {
                    // Apply filtering for manually added n-grams
                    nGramStats = this.analyzeNGrams(rawNGrams, text);
                    filteredNGrams = nGramStats.filtered;
                }
            } else {
                filteredNGrams = [];
                nGramStats = {
                    filtered: [],
                    removed: 0,
                    reasons: [],
                    details: {}
                };
            }

            const qualityScore = this.calculateSearchQuality(text, filteredNGrams);

            // Set reactive data for template binding
            glossary.details.previewStats = {
                text: text,
                length: len,
                minLen: minLen,
                maxLen: maxLen,
                totalNGrams: rawNGrams.length,
                filteredNGrams: filteredNGrams.length,
                quality: qualityScore,
                prediction: qualityScore.prediction,
                removedCount: nGramStats.removed,
                removalReasons: nGramStats.reasons
            };

            // If re-filtering occurred, update active n-grams
            if (filteredNGrams !== rawNGrams && !isAutoGenerated) {
                glossary.details.activeNGrams = filteredNGrams;
            }
        },

        addCustomNGram(glossary) {
            const input = glossary.details.customNGramInput?.trim() || '';
            if (!input) {
                this.showToast('Please enter n-gram(s)', true);
                return;
            }

            // Parse comma and space separated values
            const ngrams = input.split(/[\s,]+/)
                .map(n => n.trim().toLowerCase())
                .filter(n => n.length >= 2 && n.length <= 10); // Reasonable length limits

            if (ngrams.length === 0) {
                this.showToast('N-grams must be 2-10 characters each', true);
                return;
            }

            if (!glossary.details.activeNGrams) {
                glossary.details.activeNGrams = [];
            }

            let addedCount = 0;
            const duplicates = [];

            ngrams.forEach(ngram => {
                if (!glossary.details.activeNGrams.includes(ngram)) {
                    glossary.details.activeNGrams.push(ngram);
                    addedCount++;
                } else {
                    duplicates.push(ngram);
                }
            });

            glossary.details.customNGramInput = '';

            // Provide feedback
            if (addedCount > 0) {
                let message = `Added ${addedCount} n-gram${addedCount === 1 ? '' : 's'}`;
                if (duplicates.length > 0) {
                    message += ` (${duplicates.length} duplicate${duplicates.length === 1 ? '' : 's'} skipped)`;
                }
                this.showToast(message, false);
            } else {
                this.showToast(`All n-grams already exist`, true);
            }

            this.updateFuzzyPreview(glossary);
        },

        removeNGram(glossary, ngram) {
            if (glossary.details.activeNGrams) {
                glossary.details.activeNGrams = glossary.details.activeNGrams.filter(n => n !== ngram);
                this.updateFuzzyPreview(glossary);
            }
        },

        generateAutoNGrams(glossary) {
            const text = glossary.details.fuzzyTextInput?.trim()?.toLowerCase() || '';
            if (!text || text.length < 3) {
                this.showToast('Text must be at least 3 characters for auto n-grams', true);
                return;
            }

            try {
                glossary.details.jobLoading = true;

                // Generate trigrams with cleaning and deduplication
                const nGrams = this.generateTrigrams(text);

                // Clear existing and set auto-generated n-grams
                glossary.details.activeNGrams = nGrams;
                this.updateFuzzyPreview(glossary);
            } catch (error) {
                console.error('Error generating auto n-grams:', error);
                this.showToast('Failed to generate auto n-grams', true);
            } finally {
                glossary.details.jobLoading = false;
            }
        },

        async applyFuzzyFormat(glossary) {
            const text = glossary.details.fuzzyTextInput?.trim()?.toLowerCase() || '';
            if (!text) {
                this.resetFuzzyState(glossary);
                return;
            }

            const len = text.length;
            const minLen = Math.max(1, Math.floor(len * 0.7));
            const maxLen = Math.ceil(len * 1.3);

            // Use active n-grams if available, otherwise generate auto ones
            const nGrams = (glossary.details.activeNGrams && glossary.details.activeNGrams.length > 0)
                ? glossary.details.activeNGrams
                : this.generateTrigrams(text);

            const fuzzyData = {
                query: text,
                lengthRange: {
                    min: minLen,
                    max: maxLen
                },
                nGrams: nGrams
            };

            glossary.details.fuzzyText = JSON.stringify(fuzzyData);
            // Trigger search
            return await this.fetchRelatedGlossaryItems(glossary);
        },

        // Helper method to generate trigrams
        generateTrigrams(text) {
            // Clean the text: remove special characters, keep only letters, spaces, and numbers
            const cleanedText = text.replace(/[^a-zA-Z0-9\s]/g, '').toLowerCase();

            const nGrams = [];
            for (let i = 0; i <= cleanedText.length - 3; i++) {
                const trigram = cleanedText.substring(i, i + 3);
                // Only add trigrams that consist only of letters or numbers (no spaces in middle)
                if (/^[a-zA-Z0-9]+$/.test(trigram)) {
                    nGrams.push(trigram);
                }
            }

            // Remove duplicates and return
            return [...new Set(nGrams)];
        },

        // Check if current n-grams are auto-generated trigrams from the text
        isAutoGeneratedNGrams(text, nGrams) {
            if (!nGrams || nGrams.length === 0) return false;
            if (text.length < 3) return false;

            // Generate expected auto n-grams
            const expectedNGrams = this.generateTrigrams(text.trim().toLowerCase());

            // Check if they match exactly
            if (nGrams.length !== expectedNGrams.length) return false;

            return expectedNGrams.every((ngram, index) => ngram === nGrams[index]);
        },

        resetFuzzyState(glossary) {
            glossary.details.fuzzyTextInput = '';
            glossary.details.fuzzyPreview = '';
            glossary.details.fuzzyText = null;
            glossary.details.previewStats = {
                text: '',
                length: 0,
                minLen: 0,
                maxLen: 0,
                totalNGrams: 0,
                filteredNGrams: 0,
                quality: { level: 'None' },
                prediction: 0,
                removedCount: 0,
                removalReasons: []
            };
            glossary.details.activeNGrams = [];
            glossary.details.customNGramInput = '';
        },

        // Intelligent n-gram analysis and filtering
        analyzeNGrams(nGrams, text) {
            const result = {
                filtered: [],
                removed: 0,
                reasons: [],
                details: {}
            };

            if (!nGrams || nGrams.length === 0) {
                return result;
            }

            const textLen = text.length;
            const reasonsSet = new Set();

            nGrams.forEach(ngram => {
                const len = ngram.length;
                let isOptimal = false;
                let isGood = false;
                let keep = true;
                let reason = '';

                // Filter out n-grams shorter than 2 characters (insufficient discrimination)
                if (len < 2) {
                    keep = false;
                    reason = 'too short';
                }
                // Filter out overly long n-grams relative to text (unreliable)
                else if (len > textLen * 0.8) {
                    keep = false;
                    reason = 'too long';
                }
                // Filter out n-grams that are too rare (low frequency = unreliable results)
                else if (this.isRareNGram(ngram, text)) {
                    keep = false;
                    reason = 'too rare';
                }
                // Filter out overly common n-grams (high frequency = low discrimination)
                else if (this.isCommonNGram(ngram)) {
                    keep = false;
                    reason = 'too common';
                }
                // Check quality based on character diversity
                else if (this.hasLowDiversity(ngram)) {
                    keep = false;
                    reason = 'low diversity';
                }
                else {
                    // Determine quality
                    if (len >= 3 && len <= 5 && text.includes(ngram)) {
                        isOptimal = true;
                    } else if (len >= 2 && len <= 7) {
                        isGood = true;
                    }
                }

                if (keep) {
                    result.filtered.push(ngram);
                    result.details[ngram] = {
                        length: len,
                        isOptimal,
                        isGood,
                        quality: isOptimal ? 'optimal' : isGood ? 'good' : 'acceptable'
                    };
                } else {
                    result.removed++;
                    reasonsSet.add(reason);
                }
            });

            result.reasons = Array.from(reasonsSet);

            // Optimize n-gram count based on text length
            const recommendedCount = Math.max(3, Math.min(10, Math.floor(textLen / 2)));
            if (result.filtered.length > recommendedCount) {
                // Keep only the best n-grams
                result.filtered.sort((a, b) => {
                    const aStats = result.details[a];
                    const bStats = result.details[b];
                    if (aStats.isOptimal && !bStats.isOptimal) return -1;
                    if (!aStats.isOptimal && bStats.isOptimal) return 1;
                    if (aStats.isGood && !bStats.isGood) return -1;
                    if (!aStats.isGood && bStats.isGood) return 1;
                    return bStats.length - aStats.length; // Prefer longer n-grams
                });
                result.filtered = result.filtered.slice(0, recommendedCount);
            }

            return result;
        },

        // Check if n-gram appears too infrequently
        isRareNGram(ngram, text) {
            // Check if n-gram appears only once or twice in the text
            const regex = new RegExp(ngram, 'gi');
            const matches = text.match(regex);
            return !matches || matches.length < 2;
        },

        // Check if n-gram is overly common (like "the", "and", etc.)
        isCommonNGram(ngram) {
            const commonNGrams = [
                'the', 'and', 'ing', 'ion', 'ent', 'for', 'you', 'are', 'but', 'not',
                'can', 'had', 'her', 'was', 'one', 'our', 'out', 'day', 'get', 'has'
            ];
            return commonNGrams.includes(ngram.toLowerCase());
        },

        // Check if n-gram has low character diversity (repetitive characters)
        hasLowDiversity(ngram) {
            const uniqueChars = new Set(ngram.toLowerCase().split(''));
            const diversityRatio = uniqueChars.size / ngram.length;
            return diversityRatio < 0.6; // Less than 60% unique characters
        },

        // Calculate overall search quality
        calculateSearchQuality(text, filteredNGrams) {
            if (!filteredNGrams || filteredNGrams.length === 0) {
                return {
                    score: 0,
                    level: 'Poor',
                    color: 'red',
                    prediction: 15
                };
            }

            let qualityScore = 0;
            const textLen = text.length;
            const nGramCount = filteredNGrams.length;

            // Length factor (prefer 3-5 character n-grams)
            filteredNGrams.forEach(ngram => {
                const len = ngram.length;
                if (len >= 3 && len <= 5) qualityScore += 25; // Optimal
                else if (len >= 2 && len <= 7) qualityScore += 15; // Good
                else qualityScore += 5; // Acceptable
            });

            // Coverage factor (how well n-grams cover the text)
            const coverageChars = new Set();
            filteredNGrams.forEach(ngram => {
                for (let i = 0; i < ngram.length; i++) {
                    coverageChars.add(ngram[i].toLowerCase());
                }
            });
            const coverageRatio = coverageChars.size / Math.min(textLen, 26); // Alphabet coverage or text length
            qualityScore += coverageRatio * 20;

            // Count factor (optimal number of n-grams)
            const recommendedCount = Math.max(3, Math.min(8, Math.floor(textLen / 2.5)));
            const countDeviation = Math.abs(nGramCount - recommendedCount) / recommendedCount;
            qualityScore += (1 - countDeviation) * 30;

            // Diversity factor
            const totalDiversity = filteredNGrams.reduce((sum, ngram) => {
                const unique = new Set(ngram.split('')).size;
                return sum + (unique / ngram.length);
            }, 0) / nGramCount;
            qualityScore += totalDiversity * 25;

            // Normalize score
            const normalizedScore = Math.min(100, Math.max(0, qualityScore));
            const prediction = Math.min(95, normalizedScore * 0.8 + (nGramCount * 2));

            let level, color;
            if (normalizedScore >= 80) {
                level = 'Excellent';
                color = 'green';
            } else if (normalizedScore >= 60) {
                level = 'Good';
                color = 'blue';
            } else if (normalizedScore >= 40) {
                level = 'Fair';
                color = 'yellow';
            } else {
                level = 'Poor';
                color = 'red';
            }

            return {
                score: normalizedScore,
                level,
                color,
                prediction
            };
        },

        // Utility function for debouncing
        debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        },

    };
}
